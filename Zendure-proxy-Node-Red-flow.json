[
    {
        "id": "3a312453.f7e23c",
        "type": "tab",
        "label": "Zendure-HA proxy flow",
        "disabled": false,
        "info": ""
    },
    {
        "id": "2c1d66d1.0e367a",
        "type": "http in",
        "z": "3a312453.f7e23c",
        "name": "API Proxy In",
        "url": "/properties/report",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 90,
        "y": 379,
        "wires": [
            [
                "7e284809.30fe6",
                "e2d5e713.0a3b1"
            ]
        ]
    },
    {
        "id": "1aff08e7.0a1067",
        "type": "http request",
        "z": "3a312453.f7e23c",
        "name": "Call Zendure 1 API",
        "method": "use",
        "ret": "obj",
        "paytoqs": true,
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "authType": "",
        "x": 410,
        "y": 360,
        "wires": [
            [
                "4865609f.9c3728"
            ]
        ]
    },
    {
        "id": "4865609f.9c3728",
        "type": "join",
        "z": "3a312453.f7e23c",
        "name": "Join Responses",
        "mode": "custom",
        "build": "array",
        "property": "payload",
        "propertyType": "msg",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": true,
        "accumulate": false,
        "timeout": "1",
        "count": "2",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 620,
        "y": 379,
        "wires": [
            [
                "98c646d5.741008",
                "2c7aa6af.428d12"
            ]
        ]
    },
    {
        "id": "98c646d5.741008",
        "type": "function",
        "z": "3a312453.f7e23c",
        "name": "GET Response handling",
        "func": "/*\nHere we will add the values to the payload which are needed for HA Gielz sensors and automation\n\nTo test this proxy, run:\n% curl http://192.168.2.246:1880/properties/report\n(or the applicable url)\n\nTo access original nodes:\n% curl http://192.168.2.220/properties/report\n% curl http://192.168.2.217/properties/report\n\n*/\n\n\n\n// read serial numbers from global variable\nvar snZendure1 = flow.get('snZendure1')||\"0\";\nvar snZendure2 = flow.get('snZendure2')||\"0\";\n\n// load global variables\nvar latestPowerCmd = flow.get('latestPowerCmd') || 0;\nvar latestPowerCmd_1 = flow.get('latestPowerCmd_1') || 0;\nvar latestPowerCmd_2 = flow.get('latestPowerCmd_2') || 0;\nvar singleMode = flow.get('singleMode')||0;                              //0: no singlemode (dual mode), 1: singlemode\nvar singleMode_activedevice = flow.get('singleMode_activedevice')||0;    //0: device1, 1: device2\nvar singleMode_standby_device_A = flow.get('singleMode_standby_device_A')||0;\nvar singleMode_standby_device_B = flow.get('singleMode_standby_device_B')||0;\nvar dualMode_force_start_timestamp = flow.get('dualMode_force_start_timestamp') || 1;\nvar singleToDualModeTransition_start_timestamp = flow.get('singleToDualModeTransition_start_timestamp') || 1;\nvar singleModeDeviceChangeTranstion_timer = flow.get('singleModeDeviceChangeTranstion_timer') || 1;\nvar singleMode_upperlimit_percent = flow.get('singleMode_upperlimit_percent') || 100;\nvar singleMode_lowerlimit_percent = flow.get('singleMode_lowerlimit_percent') || 40;\nvar payloadError = flow.get('payloadError') || 0;\n\n// Initialize local variables\nlet electricLevel_A = 0;\nlet electricLevel_B = 0;\nlet electricLevel = 0;\nlet deviceTransition_active = 0;\nlet sn_A = \"\";\nlet sn_B = \"\";\n\n\n//Create a new json object to store the original and new values\nlet values = {}\nvalues.properties = {}\nvalues.original = {}\n\n\n// exit gracefully in case of error and count the error to a global variable\nif (!msg.payload || !msg.payload[0] || !msg.payload[1]) {\n    payloadError = payloadError + 1;\n    flow.set('payloadError', payloadError);\n    return null;\n}\n\n// make sure the order of objects is zendure1, zendure2\nif (msg.payload[0].sn == snZendure1 && msg.payload[1].sn == snZendure2) {\n    values.original[0] = JSON.parse(JSON.stringify(msg.payload[0] || {}));\n    values.original[1] = JSON.parse(JSON.stringify(msg.payload[1] || {}));\n} else if (msg.payload[0].sn == snZendure2 && msg.payload[1].sn == snZendure1) {\n    values.original[0] = JSON.parse(JSON.stringify(msg.payload[1] || {}));\n    values.original[1] = JSON.parse(JSON.stringify(msg.payload[0] || {}));\n} else {\n    // throw error if serialnrs from the devices are not the same as the ones the user has entered\n    sn_A = msg.payload[0].sn || \"0\";\n    sn_B = msg.payload[1].sn || \"0\";\n    if (sn_A !== \"0\" && sn_B !== \"0\" && snZendure1 !== \"0\" && snZendure2 !== \"0\") {\n        node.warn(`Serienummers komen niet overeen. Ingesteld: ${snZendure1}, ${snZendure2} â€“ Gevonden: ${sn_A}, ${sn_B}`);\n    }\n    return null;\n}\n\n\n// move battery packdata from original data to root level, as if it is one device\n// non-deep clone for speed optimization\n\nlet packData1 = [...values.original[0].packData];\nlet packData2 = [...values.original[1].packData];\n\nlet packData = [...packData1, ...packData2]\nvalues.packData = packData\n\n\n// update current SoC levels to global variable\nelectricLevel_A = (values.original[0].properties.electricLevel)\nelectricLevel_B = (values.original[1].properties.electricLevel)\nflow.set('electricLevel_A', electricLevel_A)\nflow.set('electricLevel_B', electricLevel_B)\n\n// write time of this message to variable for use in \"Resend POST\"  \nlet currentTime = Math.floor(Date.now() / 1000)\nflow.set('latestGETMessage_timestamp_epoch', currentTime)\n\n// Calculate max power value used in power distribution calculation in POST messages\n// maxpower can be different for in and out directions\n// first get the values that are configured on the Zendures \nlet chargeMaxLimit_A = values.original[0].properties.chargeMaxLimit\nlet chargeMaxLimit_B = values.original[1].properties.chargeMaxLimit\nlet inverseMaxPower_A = values.original[0].properties.inverseMaxPower\nlet inverseMaxPower_B = values.original[1].properties.inverseMaxPower\n// then calculate maxpower\nlet maxPower_in = Math.min(chargeMaxLimit_A, chargeMaxLimit_B)\nlet maxPower_out = Math.min(inverseMaxPower_A, inverseMaxPower_B)\nflow.set('maxPower_in', maxPower_in)\nflow.set('maxPower_out', maxPower_out)\n\n\n\n\n\n//----- here all variables to send to HA in the response for the combined nodes\n\n// product - we'll take the product string given by the device (Zendure 1). \n// Gielz uses this product name to determine the battery size, hence it has the be the actual product string.\nlet product = values.original[0].product || values.original[1].product;\nvalues.product = product\n\n\n// outputLimit (Output power limit)\nlet outputLimit = (values.original[0].properties.outputLimit + values.original[1].properties.outputLimit);\nvalues.properties.outputLimit = outputLimit;\n\n// inputLimit (AC charging power limit)\nlet inputLimit = (values.original[0].properties.inputLimit + values.original[1].properties.inputLimit);\nvalues.properties.inputLimit = inputLimit;\n\n// acMode (as this may be different on each node, best obtain it from a global variable, set by the POST messages to Zendure. Then at least it will be logical for HA)\n// 1: Input, 2: Output\nlet acMode = null\n\nif (singleMode == 1) {\n    if (singleMode_activedevice == 0) {\n        values.properties.acMode = values.original[0].properties.acMode;\n    } else {\n        values.properties.acMode = values.original[1].properties.acMode;\n    }\n} else {\n    acMode = (values.original[0].properties.acMode + values.original[1].properties.acMode) / 2;\n    values.properties.acMode = Math.floor(acMode);\n}\n\n// packInputPower\nlet packInputPower = (values.original[0].properties.packInputPower + values.original[1].properties.packInputPower);\nvalues.properties.packInputPower = packInputPower;\n\n// outputPackPower\nlet outputPackPower = (values.original[0].properties.outputPackPower + values.original[1].properties.outputPackPower);\nvalues.properties.outputPackPower = outputPackPower;\n\n// minSoc - select largest one\nlet minSoc_A = values.original[0].properties.minSoc;\nlet minSoc_B = values.original[1].properties.minSoc;\nlet minSoc = Math.max(minSoc_A, minSoc_B);\n\nvalues.properties.minSoc = minSoc\nflow.set('minSoc_A', minSoc_A)\nflow.set('minSoc_B', minSoc_B)\nflow.set('minSoc', minSoc)\n\n\n// socSet - select lowest one\nlet socSet_A = values.original[0].properties.socSet;\nlet socSet_B = values.original[1].properties.socSet;\nlet socSet = Math.min(socSet_A, socSet_B);\n\nvalues.properties.socSet = socSet\nflow.set('socSet_A', socSet_A)\nflow.set('socSet_B', socSet_B)\nflow.set('socSet', socSet)\n\n\n// socLimit \tint \t0: Normal state, 1: Charge limit reached, 2: Discharge limit reached\nconst socLimit_A = values.original[0].properties.socLimit\nconst socLimit_B = values.original[1].properties.socLimit\nlet socLimit = 0\n\nif (socLimit_A === 0 && socLimit_B === 0) {\n    socLimit = 0\n} else if (socLimit_A === 1 && socLimit_B === 1) {\n    socLimit = 1\n} else if (socLimit_A === 2 && socLimit_B === 2) {\n    socLimit = 2\n} else if (socLimit_A === 1 || socLimit_B === 1) {\n    socLimit = 0\n} else if (socLimit_A === 2 || socLimit_B === 2) {\n    socLimit = 0\n} else {\n    socLimit = -1 // unknown\n}\nvalues.properties.socLimit = socLimit;\n\nflow.set('socLimit', socLimit)\nflow.set('socLimit_A', socLimit_A)\nflow.set('socLimit_B', socLimit_B)\n\n\n// total battery percentage\n\nif ((socLimit_A == 2) !== (socLimit_B == 2)) {   //XOR, when only one of both devices reached battery Empty state\n    electricLevel = Math.ceil((values.original[0].properties.electricLevel + values.original[1].properties.electricLevel) / 2); // then we round up, so that discharging will continue till both are empty\n} else {\n    electricLevel = Math.floor((values.original[0].properties.electricLevel + values.original[1].properties.electricLevel) / 2);\n}\nvalues.properties.electricLevel = electricLevel\n\n\n// smartMode\n// We will send 0 if one of the nodes is at 0 (then it needs to be corrected to 1 by an HA POST command)\n// But in singleMode, if one is in smartmode=0 and the other 1, we say it is 1 (so that one device can go in Standby mode and HA does not correct it)\n// Doc: https://github.com/Zendure/zenSDK/blob/main/docs/en_properties.md\n//1: The setting parameter is not written to flash. After an unexpected power loss and restart, the device will use the value stored in flash. \n//0: The setting parameter is written to flash.\n\n// also durin transition period send smartMode=1 to HA if at least one of devices has smartMode=1.\nif ((currentTime - singleToDualModeTransition_start_timestamp < singleModeDeviceChangeTranstion_timer + 10) || (currentTime - dualMode_force_start_timestamp < singleModeDeviceChangeTranstion_timer + 10)) {  //check for transition being active\n    deviceTransition_active = 1;\n}\n\nlet smartMode_A = values.original[0].properties.smartMode;\nlet smartMode_B = values.original[1].properties.smartMode;\nlet smartMode;\nif (singleMode_standby_device_A == 1 || singleMode_standby_device_B == 1 || deviceTransition_active == 1) {\n    smartMode = Math.max(smartMode_A,smartMode_B);  // if at least one is in smartmode=1, send smartmode=1\n} else {\n    smartMode = smartMode_A * smartMode_B; // if at least one is in smartmode=0, send smartmode=0\n}\nvalues.properties.smartMode = smartMode;\nflow.set('smartMode_A', smartMode_A)\nflow.set('smartMode_B', smartMode_B)\n\n\n// BatVolt\nlet BatVolt = (values.original[0].properties.BatVolt + values.original[1].properties.BatVolt) / 2;\nvalues.properties.BatVolt = BatVolt\n\n// remainOutTime\nlet remainOutTime = (values.original[0].properties.remainOutTime + values.original[1].properties.remainOutTime) / 2;\nvalues.properties.remainOutTime = remainOutTime\n\n// hyperTmp (take the highest value)\nlet hyperTmp_A = values.original[0].properties.hyperTmp;\nlet hyperTmp_B = values.original[1].properties.hyperTmp;\nlet hyperTmp = Math.max(hyperTmp_A, hyperTmp_B);\nvalues.properties.hyperTmp = hyperTmp;\n\n\n// chargeMaxLimit\nlet chargeMaxLimit = (chargeMaxLimit_A + chargeMaxLimit_B);\nvalues.properties.chargeMaxLimit = chargeMaxLimit;\nflow.set('chargeMaxLimit_A', chargeMaxLimit_A)\nflow.set('chargeMaxLimit_B', chargeMaxLimit_B)\n\n// inverseMaxPower (Maximum output power limit)\nlet inverseMaxPower = (inverseMaxPower_A + inverseMaxPower_B);\nvalues.properties.inverseMaxPower = inverseMaxPower;\nflow.set('inverseMaxPower_A', inverseMaxPower_A)\nflow.set('inverseMaxPower_B', inverseMaxPower_B)\n\n// packNum\nlet packNum = (values.original[0].properties.packNum + values.original[1].properties.packNum);\nvalues.properties.packNum = packNum;\n\n// rssi, use the lowest of both rssi's\nlet rssi = Math.min(values.original[0].properties.rssi, values.original[1].properties.rssi);\nvalues.properties.rssi = rssi;\n\n// is_error (normaal 0; als er een >0 is, dan is het dat)\nlet is_error = Math.max(values.original[0].properties.is_error, values.original[1].properties.is_error);\nvalues.properties.is_error = is_error;\n\n\n// save socStatus for both devices to a global variable (socStatus \tint \t0: No, 1: Calibrating)\nlet socStatus_A = values.original[0].properties.socStatus;\nlet socStatus_B = values.original[1].properties.socStatus;\nflow.set('socStatus_A', socStatus_A)\nflow.set('socStatus_B', socStatus_B)\n\n// socStatus (0: No, 1: Calibrating)\nlet socStatus = Math.min(socStatus_A, socStatus_B);\nvalues.properties.socStatus = socStatus;\n\n\n\n//-----\n// additions for proxy:\n\n// serialnr\nlet sn = \"0000-PROXY-0000\"\nsn_A = values.original[0].sn;\nsn_B = values.original[1].sn;\nvalues.sn = sn\nvalues.sn_1 = sn_A\nvalues.sn_2 = sn_B\n\n\n\n// Additional socStatus for each Zendure device\nvalues.properties.socStatus_1 = socStatus_A;\nvalues.properties.socStatus_2 = socStatus_B;\n\n// Additional socLimit for each Zendure device\nvalues.properties.socLimit_1 = socLimit_A\nvalues.properties.socLimit_2 = socLimit_B\n\n// Additional battery percentage for each individual Zendure device\nvalues.properties.electricLevel_1 = electricLevel_A\nvalues.properties.electricLevel_2 = electricLevel_B\n\n// Additional: add lastest posted power and posted to the both devices\nvalues.properties.latestPowerCmd = latestPowerCmd;\nvalues.properties.latestPowerCmd_1 = latestPowerCmd_1;\nvalues.properties.latestPowerCmd_2 = latestPowerCmd_2;\n\n// send smartmode status for the individual devices\nvalues.properties.smartMode_1 = smartMode_A;\nvalues.properties.smartMode_2 = smartMode_B;\n\n// send temperature status for the individual devices\nvalues.properties.hyperTmp_1 = hyperTmp_A;\nvalues.properties.hyperTmp_2 = hyperTmp_B;\n\n// send singlemode active device status\nlet charging_limit_powerzero = (latestPowerCmd > 0 && socLimit === 1 && outputPackPower === 0)   // when limit reached do not wait for latestPowerCmd to become zero\nlet discharging_limit_powerzero = (latestPowerCmd < 0 && socLimit === 2 && packInputPower === 0) // when limit reached do not wait for latestPowerCmd to become zero\n\nif (latestPowerCmd === 0 || charging_limit_powerzero || discharging_limit_powerzero) {\n    values.properties.activeDevice = -1;   // -1: none active\n} else if (singleMode === 1) {\n    values.properties.activeDevice = singleMode_activedevice + 1;  // 1: device 1 active, 2: device 2 active\n} else {\n    values.properties.activeDevice = 0;   // 0: dual mode (both active)\n}\n\n\n\n//-----\n\n// delete from original data to keep the packet small\ndelete values.original\n\n\n// put new payload in msg.payload\nmsg.payload = values;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 379,
        "wires": [
            [
                "7e92f9a3.ef3d9",
                "f5fb6bab.a9da1"
            ]
        ]
    },
    {
        "id": "7e92f9a3.ef3d9",
        "type": "http response",
        "z": "3a312453.f7e23c",
        "name": "Send GET Response",
        "statusCode": "",
        "headers": {},
        "x": 1100,
        "y": 380,
        "wires": []
    },
    {
        "id": "7e284809.30fe6",
        "type": "debug",
        "z": "3a312453.f7e23c",
        "name": "",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "x": 350,
        "y": 280,
        "wires": []
    },
    {
        "id": "2eb9ba4e.e23d06",
        "type": "http request",
        "z": "3a312453.f7e23c",
        "name": "Call Zendure 2 API",
        "method": "use",
        "ret": "obj",
        "paytoqs": true,
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "authType": "",
        "x": 410,
        "y": 400,
        "wires": [
            [
                "4865609f.9c3728"
            ]
        ]
    },
    {
        "id": "ca12a065.2ee7f8",
        "type": "comment",
        "z": "3a312453.f7e23c",
        "name": "Proxy for data gathering (GET)",
        "info": "This part is the rest api proxy used to receive the get request from HA (Gielz) and forward it to both Zedure devices (must be equal size).\n\nThe reply consists of the replies from both devices in an array. In addition, we will add the direct values that the HA defined sensors will use to get the data that they need, derived from both responses.\n\nThe values returned to client will be whatever the intergration needs:\n\n\"electricLevel\" will be the average of both devices\n\"hyperTmp\":3011 will be the highest of both devices\n\"chargeMaxLimit\" will be from both devices added\n\"chargeMaxLimit\" will be from both devices added\n...\n",
        "x": 140,
        "y": 339,
        "wires": []
    },
    {
        "id": "e08989b9.7109d",
        "type": "comment",
        "z": "3a312453.f7e23c",
        "name": "Proxy for instruction posting (POST)",
        "info": "This part is the rest api proxy used to receive the POST request from HA (Gielz) and forward it to both Zedure devices.\n\n",
        "x": 160,
        "y": 460,
        "wires": []
    },
    {
        "id": "6abd02de.5da07c",
        "type": "http in",
        "z": "3a312453.f7e23c",
        "name": "API Proxy In",
        "url": "/properties/write",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 90,
        "y": 500,
        "wires": [
            [
                "a2ebb2d6.c26e1",
                "633308fe.069bc8"
            ]
        ]
    },
    {
        "id": "633308fe.069bc8",
        "type": "function",
        "z": "3a312453.f7e23c",
        "name": "POST Request handling",
        "func": "\n/* \nUse this example request to test:\n\n % curl -vX POST \"http://192.168.2.246:1880/properties/write\" -H \"Content-Type: application/json\" -d \"{\\\"sn\\\": \\\"xxxxx\\\",\\\"properties\\\":{\\\"acMode\\\":1, \\\"inputLimit\\\":0}}\"  \n\n % curl -vX POST \"http://192.168.2.246:1880/properties/write\" -H \"Content-Type: application/json\" -d \"{\\\"sn\\\": \\\"xxxxx\\\",\\\"properties\\\":{\\\"acMode\\\":2, \\\"outputLimit\\\":1000}}\"\n \n*/ \n\n\n\n\n// read serial numbers and IP addresses from global variable (can be modified in block \"Vul hier de Zendure IP adressen en serienummers in\")\nvar snZendure1 = flow.get('snZendure1')||1;\nvar snZendure2 = flow.get('snZendure2')||1;\nvar ipZendure1 = flow.get('ipZendure1')||1;\nvar ipZendure2 = flow.get('ipZendure2')||1;\n\n// load configurable variables (can be modified in block \"Vul hier de Zendure IP adressen en serienummers in\")\nlet maxPower_in = flow.get('maxPower_in')||800;\nlet maxPower_out = flow.get('maxPower_out')||800;\nlet tmp = flow.get('singleMode_enable');\nvar singleMode_enable = (tmp === undefined) ? 1 : tmp;    // needs special handling because it can be 0 or 1 (not needed if default is 0)\nlet balancingFactor = flow.get('balancingFactor')||1;\nlet balancingFactor_reduced = flow.get('balancingFactor_reduced') || 1;\n\n// load global variables\nvar electricLevel_A = flow.get('electricLevel_A')||50;\nvar electricLevel_B = flow.get('electricLevel_B')||50;\nvar minSoc = flow.get('minSoc')||10;   // assumption: this is set the same for both devices\nvar socSet = flow.get('socSet')||100;  // assumption: this is set the same for both devices\nvar singleMode_previous = flow.get('singleMode')||0;\nvar singleMode_change_device_diff = flow.get('singleMode_change_device_diff')||1;\nvar socStatus_A = flow.get('socStatus_A')||0;\nvar socStatus_B = flow.get('socStatus_B')||0;\nvar smartMode_A = flow.get('smartMode_A') || 0;\nvar smartMode_B = flow.get('smartMode_B') || 0;\nvar manualMode_messageRepeat = flow.get('manualMode_messageRepeat')||0;\nvar latestPowerMessage_timestamp_epoch = flow.get('latestPowerMessage_timestamp_epoch')||1;\nvar socLimit_A = flow.get('socLimit_A')||0;\nvar socLimit_B = flow.get('socLimit_B')||0;\nvar latestPowerCmd_1_zero_timestamp = flow.get('latestPowerCmd_1_zero_timestamp')||1;\nvar latestPowerCmd_2_zero_timestamp = flow.get('latestPowerCmd_2_zero_timestamp')||1;\nvar singleMode_standby_device_A = flow.get('singleMode_standby_device_A')||0;\nvar singleMode_standby_device_B = flow.get('singleMode_standby_device_B')||0;\nvar acMode_previous = flow.get('acMode')||0;\nvar singleMode_activedevice_previous = flow.get('singleMode_activedevice')||0;\nvar latestPowerCmd_1_previous = flow.get('latestPowerCmd_1')||0;\nvar latestPowerCmd_2_previous = flow.get('latestPowerCmd_2')||0;\nvar singleModeDeviceChangeTranstion_timer = flow.get('singleModeDeviceChangeTranstion_timer') || 20;\nvar dualMode_force_start_timestamp = flow.get('dualMode_force_start_timestamp') || 1;\nvar dualMode_force_original_device = flow.get('dualMode_force_original_device') || 0;\nvar singleToDualModeTransition_start_timestamp = flow.get('singleToDualModeTransition_start_timestamp') || 1;\nvar singleToDualModeTransition_original_device = flow.get('singleToDualModeTransition_original_device') || 0;\n\n// load global variables coming from node \"Check Stuff\"\nlet singleMode_upperlimit_in = flow.get('singleMode_upperlimit_in') || 800;\nlet singleMode_upperlimit_out = flow.get('singleMode_upperlimit_out') || 800;\nlet singleMode_lowerlimit_in = flow.get('singleMode_lowerlimit_in') || 500;\nlet singleMode_lowerlimit_out = flow.get('singleMode_lowerlimit_out') || 500;\n\n\n\n// initialization of variables\nlet boostAmount = 0\nlet inputLimit = 0\nlet outputLimit = 0\nlet Power_A = 0\nlet Power_B = 0\nlet Avail_A = 0\nlet Avail_B = 0\nlet Avail_Total = 0\nlet latestPowerMessage = \"\"\nlet currentTime = Math.floor(Date.now() / 1000)\nlet singleMode_change_device_diff_used = 1\nlet latestPowerCmd = 0\nlet latestPowerCmd_1 = 0\nlet latestPowerCmd_2 = 0\nlet acMode = 0\nlet smartMode_1_only_packet = 0\nlet singleMode = singleMode_previous\nlet singleMode_activedevice = singleMode_activedevice_previous //default to previous\nlet forcedDualModeActive = 0\nlet singleToDualModeTransition_active = 0\nlet chargeMaxLimit = 0\nlet inverseMaxPower = 0\nlet power_message = 0\n\n// Define target servers\nlet server1 = \"http://\" + ipZendure1 + \"/properties/write\";\nlet server2 = \"http://\" + ipZendure2 + \"/properties/write\";\n\n// The incoming POST body\nlet data = msg.payload;  //changed back to non-deep clone for speed optimization\n//let data = JSON.parse(JSON.stringify(msg.payload)); \n\n// Keep a reference to req/res for later response\nlet req = msg.req;\nlet res = msg.res;\n\n// Save the URL, to be used in the Resend Post block\nlet latestPowerMessage_host = req.headers.host + req.originalUrl\n\n// Make deep clones of the payload, to use for both messages to the both Zendures\nlet data1 = JSON.parse(JSON.stringify(data));\nlet data2 = JSON.parse(JSON.stringify(data));\n\n\n// Set the Zendure device serial numbers\ndata1.sn = snZendure1;\ndata2.sn = snZendure2;\n\n\n\n\n\n// Save the acMode of the current message, if present\nif (\"acMode\" in data.properties) {\n    acMode = data.properties.acMode;\n    flow.set('acMode', acMode)\n} else {\n    acMode = acMode_previous\n}\n\n\n\n// Charging - inputLimit\n\nif (\"inputLimit\" in data.properties) {\n    // charging\n\n\n    if (typeof data.repeat == \"undefined\" ) { /// if this is not already a repeat message\n        // add timestamp, to check age later before resending\n        flow.set('latestPowerMessage_host', latestPowerMessage_host)\n        flow.set('latestPowerMessage_timestamp_epoch', currentTime)\n\n        //latestPowerMessage = JSON.parse(JSON.stringify(msg.payload)); // clone it // save payload of message, so that it can be repeated in manual mode\n        latestPowerMessage = data; //changed to non-deep clone for speed optimization\n\n        flow.set('latestPowerMessage', JSON.parse(JSON.stringify(data)));  //save as deep clone\n\n    }\n    \n    // drop repeat message if it follows quickly after the latest powermessage (to avoid a race condition)\n    if (typeof data.repeat != \"undefined\") {\n        if (currentTime - latestPowerMessage_timestamp_epoch < 1) {\n            \n            return [null, null];\n        }\n    }\n    \n    \n    \n    inputLimit = data.properties.inputLimit\n\n\n    // manage singleMode status\n\n    // check for singleToDualModeTransition being active, then keep it in dual mode during the transition\n    if (currentTime - singleToDualModeTransition_start_timestamp < singleModeDeviceChangeTranstion_timer) {  //check for single to dualmode transition being active\n        singleToDualModeTransition_active = 1\n        singleMode = 0; \n        \n\n    } else if ((electricLevel_A < minSoc / 10) !== (electricLevel_B < minSoc / 10)) {\n        singleMode = 1;                   // if Soc of one device is below minSoc, but not both (XOR), force using single mode, regardless of power. \n                                          // That will prevent one of the devices to charge above MinSoc while the other is still (far) below minSoc.\n    } else if ((socLimit_A == 1) !== (socLimit_B == 1)) {   //XOR, when only one of both devices reached battery Full state\n        singleMode = 1;                   // if exactly one device is Full, always use single mode to charge, regardless of power. \n    } else if ((electricLevel_A >= 98 || electricLevel_B >= 98) && (Math.ceil((electricLevel_A + electricLevel_B) / 2) >= (98 - singleMode_change_device_diff))) {\n        singleMode = 0;                     // at 98%+ SoC the charging goes slower, so then better always share the load over both devices \n    } else if (inputLimit < singleMode_lowerlimit_in) {\n        singleMode = 1;\n    } else if (inputLimit > singleMode_upperlimit_in) {\n        singleMode = 0;\n    }\n    flow.set('singleMode', singleMode)\n\n\n\n\n    // when still in single mode, and singleModeDeviceChangeTranstion is active, force dual mode and set forcedDualModeActive = 1\n    if (singleMode == 1 && currentTime - dualMode_force_start_timestamp < singleModeDeviceChangeTranstion_timer) {  //check for forced dualmode being active\n        singleMode = 0;\n        forcedDualModeActive = 1;\n    }\n\n\n\n    if (singleMode == 1) { // determine 'highest device' during single mode, which is used for determining which is the active device\n\n        // When charging from below minSoc, 1% diff will be enough to trigger active device change if needed (to make sure both reach minSoc exactly).\n        if ((socLimit_A == 2 || socLimit_B == 2) && (electricLevel_A < (minSoc / 10) || electricLevel_B < (minSoc / 10) )) {\n            singleMode_change_device_diff_used = 1;\n        } else {\n            singleMode_change_device_diff_used = singleMode_change_device_diff;\n        }\n\n        // Determine active device\n        // Determine new active device if SoC difference is at least the singleMode_change_device_diff_used OR if previous mode was dualMode, ELSE keep using same active device\n\n        // if only one device is Full (reached socSet), make sure that the other device becomes marked as the singleMode_activedevice to be charged\n        if ((socLimit_A == 1) !== (socLimit_B == 1)) {   //XOR, when only one of both devices reached battery Full state\n            if (socLimit_A == 1) {\n                singleMode_activedevice = 1 //device B\n            } else {\n                singleMode_activedevice = 0 //device A\n            }\n        } else if (electricLevel_A > electricLevel_B) {\n            if (electricLevel_A - electricLevel_B >= singleMode_change_device_diff_used || singleMode_previous == 0 || (smartMode_A == 0 && smartMode_B ==0)) {  // to change device less often, we will require % diff to be higher to change\n                singleMode_activedevice = 1 //device B\n            } else {\n                singleMode_activedevice = singleMode_activedevice_previous;\n            }\n        } else if (electricLevel_A < electricLevel_B) {\n            if (electricLevel_B - electricLevel_A >= singleMode_change_device_diff_used || singleMode_previous == 0 || (smartMode_A == 0 && smartMode_B == 0)) {  // to change device less often, we will require % diff to be higher to change\n                singleMode_activedevice = 0 //device A\n            } else {\n                singleMode_activedevice = singleMode_activedevice_previous;\n            }\n        } else {\n            singleMode_activedevice = singleMode_activedevice_previous;\n        }\n        flow.set('singleMode_activedevice', singleMode_activedevice)\n\n\n        // at change of active device in single mode, trigger dual mode for x seconds for a smoother transition\n        if ((forcedDualModeActive != 1 && (singleMode_activedevice != singleMode_activedevice_previous) && singleMode_previous == 1 && (socLimit_A != 1 && socLimit_B != 1) && (!(smartMode_A == 0 && smartMode_B == 0)))) { \n            singleMode = 0;\n            dualMode_force_start_timestamp = currentTime;  // set timestamp as start of forced dual mode at single mode device change\n            dualMode_force_original_device = singleMode_activedevice_previous\n            forcedDualModeActive = 1\n            flow.set('dualMode_force_start_timestamp', dualMode_force_start_timestamp)\n            flow.set('dualMode_force_original_device', dualMode_force_original_device)\n        }\n\n    } else {  // singlemode == 0 here (Dual Mode)  // Trigger single to dual mode transition\n        if (singleMode_previous == 1 && singleToDualModeTransition_active != 1 && forcedDualModeActive != 1 && !(smartMode_A == 0 && smartMode_B == 0) && (latestPowerCmd_1_previous != 0 && latestPowerCmd_2_previous != 0) ) {   //transition from single to dual mode and not already in transition and not both in non-smart (sleep) mode and not previous at zero power\n            singleToDualModeTransition_start_timestamp = currentTime;\n            singleToDualModeTransition_original_device = singleMode_activedevice_previous\n            singleToDualModeTransition_active = 1\n            flow.set('singleToDualModeTransition_start_timestamp', singleToDualModeTransition_start_timestamp)\n            flow.set('singleToDualModeTransition_original_device', singleToDualModeTransition_original_device)\n\n        }\n\n        // when soc% diff is just 1%, keep the balancingFactor at 1. This will reduce the power jumps at soc% jump.\n        if (Math.abs(electricLevel_A - electricLevel_B) == 1) {\n            balancingFactor = balancingFactor_reduced;\n        }\n    }\n\n\n    if (inputLimit === 0) {\n        Power_A = 0;\n        Power_B = 0;\n    } else {\n        \n        //// TRANSITION TO ADD NEW DEVICE (single device to dual device)\n        if (singleToDualModeTransition_active == 1) {  //during transition from single to dual mode, let the original device have most of the power\n\n\n            if (currentTime - singleToDualModeTransition_start_timestamp < singleModeDeviceChangeTranstion_timer * 0.75) {  // first start with most power on original device\n\n                //node.warn(\"singleToDualModeTransition_original_device is \" + singleToDualModeTransition_original_device);\n                if (singleToDualModeTransition_original_device == 0) {\n                    Avail_A = 95;\n                    Avail_B = 5;\n                } else {\n                    Avail_A = 5;\n                    Avail_B = 95;\n                }\n            } else {  //end the singleToDualModeTransition_active period with more power to the new device, before the old device goes to equal power\n                if (singleToDualModeTransition_original_device == 0) {\n                    Avail_A = 75;\n                    Avail_B = 25;\n                } else {\n                    Avail_A = 25;\n                    Avail_B = 75;\n                }\n            }\n            balancingFactor = 1 // just give proportional power, no extra balancingFactor\n\n\n        //// TRANSITION TO ADD NEW DEVICE (single device to new single device)\n        } else if (forcedDualModeActive == 1) {    // during forced dual mode due to switch of singlemode device, we want to give the original device most of the power\n                                            // while the new device is waking up\n            if (currentTime - dualMode_force_start_timestamp < singleModeDeviceChangeTranstion_timer * 0.57) {  // first start with most power on original device\n\n                if (dualMode_force_original_device == 0) {\n                    Avail_A = 95;\n                    Avail_B = 5;\n                } else {\n                    Avail_A = 5;\n                    Avail_B = 95;\n                }\n\n            } else if (currentTime - dualMode_force_start_timestamp < singleModeDeviceChangeTranstion_timer * 0.71) { // transition slowly to new device\n\n                if (dualMode_force_original_device == 0) {\n                    Avail_A = 75;\n                    Avail_B = 25;\n                } else {\n                    Avail_A = 25;\n                    Avail_B = 75;\n                }\n\n            } else if (currentTime - dualMode_force_start_timestamp < singleModeDeviceChangeTranstion_timer * 0.85) { // transition slowly to new device \n                Avail_A = 50;\n                Avail_B = 50;\n\n            } else {  //end the forcedDualModeActive period with more power to the new device, before the old device goes to zero\n\n                if (dualMode_force_original_device == 0) {\n                    Avail_A = 25;\n                    Avail_B = 75;\n                } else {\n                    Avail_A = 75;\n                    Avail_B = 25;\n                }\n            }\n            balancingFactor = 1 // just give proportional power, no extra balancingFactor\n            //// END OF TRANSITION TO ADD NEW DEVICE\n\n\n        } else {   // normal case\n            Avail_A = socSet/10 - electricLevel_A  // available storage to charge\n            if (Avail_A < 0 || socStatus_A == 1) { // also make zero when device is Calibrating\n                Avail_A = 0\n            }\n            Avail_B = socSet/10 - electricLevel_B  // available storage to charge\n            if (Avail_B < 0 || socStatus_B == 1) { // also make zero when device is Calibrating\n                Avail_B = 0\n            }\n            \n            //in singleMode, let the non-active device be zero, so that the active takes all\n            if (singleMode == 1 && singleMode_enable == 1) {\n                if (singleMode_activedevice === 0) { //device A is active\n                Avail_A = 1\n                Avail_B = 0\n                } else { //device B is highest\n                Avail_A = 0\n                Avail_B = 1\n                }\n            }\n        }\n\n        //calculation for power A and B\n        if (Avail_A == Avail_B) {\n            Power_A = Math.floor(inputLimit / 2);\n            if (Power_A > maxPower_in) {\n                Power_A = maxPower_in\n            }\n            Power_B = Power_A\n        } else {   // unequal storage available to charge\n                    // start with the highest available one, determine it's power, proportional to available storage\n            Avail_Total = Avail_A + Avail_B\n            if (Avail_A > Avail_B) {\n                Power_A = Math.floor((Avail_A / Avail_Total) * inputLimit * balancingFactor)\n                if (Power_A > inputLimit) {\n                    Power_A = inputLimit\n                }\n                if (Power_A > maxPower_in) {\n                    Power_A = maxPower_in\n                }\n                Power_B = inputLimit - Power_A  // the smaller one takes the rest\n                if (Power_B > maxPower_in) {\n                    Power_B = maxPower_in\n                } \n            } else if (Avail_B > Avail_A) {\n                Power_B = Math.floor((Avail_B / Avail_Total) * inputLimit * balancingFactor)\n                if (Power_B > inputLimit) {\n                    Power_B = inputLimit\n                }\n                if (Power_B > maxPower_in) {\n                    Power_B = maxPower_in\n                } \n                Power_A = inputLimit - Power_B\n                if (Power_A > maxPower_in) {\n                    Power_A = maxPower_in\n                }\n            }\n        }\n\n        //in singleMode, let the non-active device be zero Power (except when soc < minsoc)\n        if (singleMode == 1 && singleMode_enable == 1 && !((electricLevel_A < (minSoc / 10) || electricLevel_B < (minSoc / 10)))) {\n            if (singleMode_activedevice === 0) { //device A is active\n            Power_B = 0\n            } else { //device B is active\n            Power_A = 0\n            }\n        }\n\n        // if Avail_A and Avail_B are both zero, let the Power be also zero on both (avoids standby device to be taken out of Standby when socset reached)\n        if ((Avail_A === 0 && Avail_B === 0) || (socLimit_A == 1 && socLimit_B == 1)) {\n            Power_A = 0\n            Power_B = 0\n        }\n\n    }\n    data1.properties.inputLimit = Power_A\n    data2.properties.inputLimit = Power_B\n\n    //saving power posted and posted to both devices, for including in GET status message\n    latestPowerCmd = inputLimit\n    latestPowerCmd_1 = Power_A\n    latestPowerCmd_2 = Power_B\n    flow.set('latestPowerCmd', latestPowerCmd)\n    flow.set('latestPowerCmd_1', latestPowerCmd_1)\n    flow.set('latestPowerCmd_2', latestPowerCmd_2)\n\n    // saving timestamp if one device is set to 0 power; set timestamp to 1 if power is not zero\n    if (latestPowerCmd_1 == 0 || latestPowerCmd_2 == 0) {   //OR, one or both of them are zero\n\n        if (latestPowerCmd_1 != 0) {\n        latestPowerCmd_1_zero_timestamp = 1;\n        } else if (latestPowerCmd_1 == 0 && latestPowerCmd_1_previous != 0) {\n            latestPowerCmd_1_zero_timestamp = currentTime\n        }\n        flow.set('latestPowerCmd_1_zero_timestamp', latestPowerCmd_1_zero_timestamp);\n\n        if (latestPowerCmd_2 != 0) {\n        latestPowerCmd_2_zero_timestamp = 1;\n        } else if (latestPowerCmd_2 == 0 && latestPowerCmd_2_previous != 0) {\n            latestPowerCmd_2_zero_timestamp = currentTime\n        }\n        flow.set('latestPowerCmd_2_zero_timestamp', latestPowerCmd_2_zero_timestamp);\n\n    }\n\n}\n\n\n\n//################\n\n// Discharging - outputlimit; instead of available storage, use available charge stored\n\nif (\"outputLimit\" in data.properties) {\n    // discharging\n\n    if (typeof data.repeat == \"undefined\" ) { /// if this is not already a repeat message\n        // add timestamp, to check age later before resending\n        flow.set('latestPowerMessage_host', latestPowerMessage_host)\n        flow.set('latestPowerMessage_timestamp_epoch', currentTime)\n        \n        //latestPowerMessage = JSON.parse(JSON.stringify(msg.payload)); // clone it // save payload of message, so that it can be repeated in manual mode\n        latestPowerMessage = data; //changed to non-deep clone for speed optimization\n        \n        flow.set('latestPowerMessage', JSON.parse(JSON.stringify(data)));  //save as deep clone\n\n    }\n    \n    // drop repeat message if it follows quickly after the latest powermessage (to avoid a race condition)\n    if (typeof data.repeat != \"undefined\") {\n        if (currentTime - latestPowerMessage_timestamp_epoch < 2) {\n            return [null, null];\n        }\n    }\n\n\n    outputLimit = data.properties.outputLimit\n    \n    // first default to singlemode when both devices are in socset\n    if (socLimit_A == 1 && socLimit_B == 1) {\n        singleMode = 1;  //reset to singlemode when socset reached, so that start will be by default with singlemode next time.\n    }\n\n\n    // manage singleMode status\n\n    // check for singleToDualModeTransition being active, then keep it in dual mode during the transition\n    if (currentTime - singleToDualModeTransition_start_timestamp < singleModeDeviceChangeTranstion_timer) {  //check for single to dualmode transition being active\n        singleToDualModeTransition_active = 1\n        singleMode = 0; \n\n    } else if ((electricLevel_A <= minSoc / 10) !== (electricLevel_B <= minSoc / 10)) {\n        singleMode = 1;                   // if Soc of exactly one device is below or equal to minSoc, always use single mode to discharge, regardless of power. \n    } else if ((socLimit_A == 2) !== (socLimit_B == 2)) {   //XOR, when only one of both devices reached battery Empty state\n        singleMode = 1;                   // if exactly one device is Empty, always use single mode to discharge, regardless of power. \n    } else if (outputLimit < singleMode_lowerlimit_out) {\n        singleMode = 1;\n    } else if (outputLimit > singleMode_upperlimit_out) {\n        singleMode = 0;\n    }\n    flow.set('singleMode', singleMode)\n\n\n\n    // when still in single mode, and singleModeDeviceChangeTranstion is active, force dual mode and set forcedDualModeActive = 1\n    if (singleMode == 1 && currentTime - dualMode_force_start_timestamp < singleModeDeviceChangeTranstion_timer) {  //check for forced dualmode being active\n        singleMode = 0;\n        forcedDualModeActive = 1;\n    }\n\n\n    if (singleMode == 1) { // determine 'highest device' during single mode, which is used for determining which is the active device\n\n        // When discharging with one device at minSoc, set the singleMode_change_device_diff_used to 1\n        if (socLimit_A == 2 || socLimit_B == 2) {\n            singleMode_change_device_diff_used = 1;\n        } else {\n            singleMode_change_device_diff_used = singleMode_change_device_diff;\n        }\n\n        // if only one device is Empty (may still be minSoc+1 % in some cases), make sure that the other device becomes marked as the singleMode_highestdevice to be discharged\n        if ((socLimit_A == 2) !== (socLimit_B == 2)) {   //XOR, when only one of both devices reached battery Empty state\n            if (socLimit_A == 2) {\n                singleMode_activedevice = 1 //device B\n            } else {\n                singleMode_activedevice = 0 //device A\n            }\n        } else if (electricLevel_A > electricLevel_B) {\n            if (electricLevel_A - electricLevel_B >= singleMode_change_device_diff_used || singleMode_previous == 0 || (smartMode_A == 0 && smartMode_B == 0)) {  // to change device less often, we will require % diff to be higher to change\n                singleMode_activedevice = 0 //device A\n            } else {\n                singleMode_activedevice = singleMode_activedevice_previous;\n            }\n        } else if (electricLevel_A < electricLevel_B) {\n            if (electricLevel_B - electricLevel_A >= singleMode_change_device_diff_used || singleMode_previous == 0 || (smartMode_A == 0 && smartMode_B == 0)) {  // to change device less often, we will require % diff to be higher to change\n                singleMode_activedevice = 1 //device B\n            } else {\n                singleMode_activedevice = singleMode_activedevice_previous;\n            }\n        } else {\n            singleMode_activedevice = singleMode_activedevice_previous;\n        }\n        flow.set('singleMode_activedevice', singleMode_activedevice)\n\n        \n        // at change of active device in single mode, trigger dual mode for x seconds for a smoother transition\n        if ((forcedDualModeActive != 1 && (singleMode_activedevice != singleMode_activedevice_previous) && singleMode_previous == 1 && (socLimit_A != 2 && socLimit_B != 2) && (!(smartMode_A == 0 && smartMode_B == 0)))) {\n            singleMode = 0;\n            dualMode_force_start_timestamp = currentTime;  // set timestamp as start of forced dual mode at single mode device change\n            dualMode_force_original_device = singleMode_activedevice_previous\n            forcedDualModeActive = 1\n            flow.set('dualMode_force_start_timestamp', dualMode_force_start_timestamp)\n            flow.set('dualMode_force_original_device', dualMode_force_original_device)\n        }\n\n    } else {  // singlemode == 0 here (Dual Mode)  // Trigger single to dual mode transition\n        if (singleMode_previous == 1 && singleToDualModeTransition_active != 1 && forcedDualModeActive != 1 && !(smartMode_A == 0 && smartMode_B == 0) && (latestPowerCmd_1_previous != 0 && latestPowerCmd_2_previous != 0) ) {   //transition from single to dual mode and not already in transition or sleep mode or previous in zero power\n            singleToDualModeTransition_start_timestamp = currentTime;\n            singleToDualModeTransition_original_device = singleMode_activedevice_previous\n            singleToDualModeTransition_active = 1\n            flow.set('singleToDualModeTransition_start_timestamp', singleToDualModeTransition_start_timestamp)\n            flow.set('singleToDualModeTransition_original_device', singleToDualModeTransition_original_device)\n\n        }\n\n        // when soc% diff is just 1%, keep the balancingFactor at 1. This will reduce the power jumps at soc% jump.\n        if (Math.abs(electricLevel_A - electricLevel_B) == 1 ) {\n            balancingFactor = balancingFactor_reduced;\n        }\n    }\n\n    \n    if (outputLimit === 0) {\n        Power_A = 0;\n        Power_B = 0;\n    } else {\n        \n        //// TRANSITION TO ADD NEW DEVICE (single device to dual device)\n        if (singleToDualModeTransition_active == 1) {  //during transition from single to dual mode, let the original device have most of the power\n\n            if (currentTime - singleToDualModeTransition_start_timestamp < singleModeDeviceChangeTranstion_timer * 0.75) {  // first start with most power on original device\n\n                if (singleToDualModeTransition_original_device == 0) {\n                    Avail_A = 95;\n                    Avail_B = 5;\n                } else {\n                    Avail_A = 5;\n                    Avail_B = 95;\n                }\n            } else {  //end the singleToDualModeTransition_active period with more power to the new device, before the old device goes to equal power\n                if (singleToDualModeTransition_original_device == 0) {\n                    Avail_A = 75;\n                    Avail_B = 25;\n                } else {\n                    Avail_A = 25;\n                    Avail_B = 75;\n                }\n            }\n            balancingFactor = 1 // just give proportional power, no extra balancingFactor\n\n\n            //// TRANSITION TO ADD NEW DEVICE (single device to new single device)\n        } else if (forcedDualModeActive == 1) {    // during forced dual mode due to switch of singlemode device, we want to give the original device most of the power\n            // while the new device is waking up\n            if (currentTime - dualMode_force_start_timestamp < singleModeDeviceChangeTranstion_timer * 0.57) {  // first start with most power on original device\n\n                if (dualMode_force_original_device == 0) {\n                    Avail_A = 95;\n                    Avail_B = 5;\n                } else {\n                    Avail_A = 5;\n                    Avail_B = 95;\n                }\n            \n            } else if (currentTime - dualMode_force_start_timestamp < singleModeDeviceChangeTranstion_timer * 0.71) { // transition slowly to new device\n\n                if (dualMode_force_original_device == 0) {\n                    Avail_A = 75;\n                    Avail_B = 25;\n                } else {\n                    Avail_A = 25;\n                    Avail_B = 75;\n                }\n            \n            } else if (currentTime - dualMode_force_start_timestamp < singleModeDeviceChangeTranstion_timer * 0.85) { // transition slowly to new device \n                Avail_A = 50;\n                Avail_B = 50;\n\n            } else {  //end the forcedDualModeActive period with more power to the new device, before the old device goes to zero\n\n                if (dualMode_force_original_device == 0) {\n                    Avail_A = 25;\n                    Avail_B = 75;\n                } else {\n                    Avail_A = 75;\n                    Avail_B = 25;\n                }\n            }\n            balancingFactor = 1 // just give proportional power, no extra balancingFactor\n        //// END OF TRANSITION TO ADD NEW DEVICE\n            \n            \n        } else {   // normal case\n            Avail_A = electricLevel_A - minSoc/10  // available charge stored\n            if (Avail_A < 0 || socStatus_A == 1) { // also make zero when device is Calibrating\n                Avail_A = 0\n            }\n            Avail_B = electricLevel_B - minSoc/10  // available charge stored\n            if (Avail_B < 0 || socStatus_B == 1) { // also make zero when device is Calibrating\n                Avail_B = 0\n            }\n            \n            //in singleMode, let the non-active device be zero, so that the active takes all\n            if (singleMode == 1 && singleMode_enable == 1) {\n                if (singleMode_activedevice === 0) { //device A is active\n                Avail_A = 1\n                Avail_B = 0\n                } else { //device B is active\n                Avail_B = 1\n                Avail_A = 0\n                }\n            }\n        }\n        \n        //calculation for power A and B\n        if (Avail_A == Avail_B) {\n            Power_A = Math.floor(outputLimit / 2);\n            if (Power_A > maxPower_out) {\n                Power_A = maxPower_out\n            }\n            Power_B = Power_A\n        } else {   // unequal charge available to discharge\n                    // start with the highest available one, determine it's power, proportional to available storage\n            Avail_Total = Avail_A + Avail_B\n            if (Avail_A > Avail_B) {\n                Power_A = Math.floor((Avail_A / Avail_Total) * outputLimit * balancingFactor)\n                if (Power_A > outputLimit) {\n                    Power_A = outputLimit\n                }\n                if (Power_A > maxPower_out) {\n                    Power_A = maxPower_out\n                } \n                Power_B = outputLimit - Power_A  // the smaller one takes the rest\n                if (Power_B > maxPower_out) {\n                    Power_B = maxPower_out\n                }\n            } else if (Avail_B > Avail_A) {\n                Power_B = Math.floor((Avail_B / Avail_Total) * outputLimit * balancingFactor)\n                if (Power_B > outputLimit) {\n                    Power_B = outputLimit\n                }\n                if (Power_B > maxPower_out) {\n                    Power_B = maxPower_out\n                } \n                Power_A = outputLimit - Power_B\n                if (Power_A > maxPower_out) {\n                    Power_A = maxPower_out\n                } \n            }\n        }\n\n        //in singleMode, let the non-active device be zero Power\n        if (singleMode == 1 && singleMode_enable == 1) {\n            if (singleMode_activedevice === 0) { //device A is active\n            Power_B = 0\n            } else { //device B is active\n            Power_A = 0\n            }\n        }\n\n        // if Avail_A and Avail_B are both zero, let the Power be also zero on both (avoids standby device to be taken out of Standby when minsoc reached)\n        if ((Avail_A === 0 && Avail_B === 0) || (socLimit_A == 2 && socLimit_B == 2)) {\n            Power_A = 0\n            Power_B = 0\n        }\n\n    }\n    data1.properties.outputLimit = Power_A\n    data2.properties.outputLimit = Power_B\n\n\n    //saving power posted and posted to both devices, for including in REST API status message\n    latestPowerCmd = outputLimit * -1\n    latestPowerCmd_1 = Power_A * -1\n    latestPowerCmd_2 = Power_B * -1\n    flow.set('latestPowerCmd', latestPowerCmd)\n    flow.set('latestPowerCmd_1', latestPowerCmd_1)\n    flow.set('latestPowerCmd_2', latestPowerCmd_2)\n\n    // saving timestamp if one device is set to 0 power; set timestamp to 1 if power is not zero\n    if (latestPowerCmd_1 == 0 || latestPowerCmd_2 == 0) {   //OR, one or both of them are zero\n\n        if (latestPowerCmd_1 != 0) {\n        latestPowerCmd_1_zero_timestamp = 1;\n        } else if (latestPowerCmd_1 == 0 && latestPowerCmd_1_previous != 0) {\n            latestPowerCmd_1_zero_timestamp = currentTime\n        }\n        flow.set('latestPowerCmd_1_zero_timestamp', latestPowerCmd_1_zero_timestamp);\n\n        if (latestPowerCmd_2 != 0) {\n        latestPowerCmd_2_zero_timestamp = 1;\n        } else if (latestPowerCmd_2 == 0 && latestPowerCmd_2_previous != 0) {\n            latestPowerCmd_2_zero_timestamp = currentTime\n        }\n        flow.set('latestPowerCmd_2_zero_timestamp', latestPowerCmd_2_zero_timestamp);\n\n    }\n\n}\n\n\n// Handle chargeMaxLimit and inverseMaxPower POST message\nif (\"chargeMaxLimit\" in data.properties) {\n    chargeMaxLimit = data.properties.chargeMaxLimit;\n    data1.properties.chargeMaxLimit = Math.floor(chargeMaxLimit / 2);\n    data2.properties.chargeMaxLimit = Math.floor(chargeMaxLimit / 2);\n}\nif (\"inverseMaxPower\" in data.properties) {\n    inverseMaxPower = data.properties.inverseMaxPower;\n    data1.properties.inverseMaxPower = Math.floor(inverseMaxPower / 2);\n    data2.properties.inverseMaxPower = Math.floor(inverseMaxPower / 2);\n}\n\n\n\n// add smartMode=1 (get out of Standby) in case power is not zero and device is in smartMode=1\nif (singleMode_standby_device_A == 1 && Power_A != 0) {\n    data1.properties.acMode = acMode\n    data1.properties.smartMode = 1;\n    singleMode_standby_device_A = 0;\n    flow.set('singleMode_standby_device_A', singleMode_standby_device_A)\n}\nif (singleMode_standby_device_B == 1 && Power_B != 0) {\n    data2.properties.acMode = acMode\n    data2.properties.smartMode = 1\n    singleMode_standby_device_B = 0\n    flow.set('singleMode_standby_device_B', singleMode_standby_device_B)\n}\n\n\n// Build the two messages\nlet msg1 = {\n    method: \"POST\",\n    url: server1,\n    headers: { \"Content-Type\": \"application/json\" },\n    payload: data1,\n    req: req,\n    res: res\n};\n\nlet msg2 = {\n    method: \"POST\",\n    url: server2,\n    headers: { \"Content-Type\": \"application/json\" },\n    payload: data2,\n    req: req,\n    res: res\n};\n\n\nif (\"smartMode\" in data.properties) {\n    if (data.properties.smartMode == 1 && !(\"inputLimit\" in data.properties) && !(\"outputLimit\" in data.properties)) {\n        smartMode_1_only_packet = 1;\n    }\n}\n\nif ((\"inputLimit\" in data.properties) || (\"outputLimit\" in data.properties)) {\n    power_message = 1;\n}\n\n// Do not send message for Power zero to device in singleMode_standby (to avoid it to be written to the flash)\n// or if it contains smartmode=1 (to prevent Gielz setting smartmode=1 to this standby device, which we will not change later anymore due to message already sent for this timestamp)\n// pass everything else to both devices.\nif (singleMode_standby_device_A == 1 && ((Power_A == 0 && power_message == 1) || smartMode_1_only_packet == 1)) {\n    msg1 = null\n}\nif (singleMode_standby_device_B == 1 && ((Power_B == 0 && power_message == 1) || smartMode_1_only_packet == 1)) {\n    msg2 = null\n}\n\n// Return both messages (to the two HTTP request outputs)\nreturn [msg1, msg2];\n",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 330,
        "y": 500,
        "wires": [
            [
                "5423b2ef.ac5bac",
                "165be43a.2f0cac"
            ],
            [
                "5cc81e91.59c73",
                "165be43a.2f0cac"
            ]
        ]
    },
    {
        "id": "5423b2ef.ac5bac",
        "type": "http request",
        "z": "3a312453.f7e23c",
        "name": "Call Zendure 1 API",
        "method": "use",
        "ret": "obj",
        "paytoqs": true,
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "authType": "",
        "x": 630,
        "y": 480,
        "wires": [
            [
                "3aea589e.262988",
                "c5194ed0.a1db28"
            ]
        ]
    },
    {
        "id": "5cc81e91.59c73",
        "type": "http request",
        "z": "3a312453.f7e23c",
        "name": "Call Zendure 2 API",
        "method": "use",
        "ret": "obj",
        "paytoqs": true,
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "authType": "",
        "x": 630,
        "y": 520,
        "wires": [
            [
                "3aea589e.262988",
                "c5194ed0.a1db28"
            ]
        ]
    },
    {
        "id": "6099f061.898ce8",
        "type": "http response",
        "z": "3a312453.f7e23c",
        "name": "Send POST Response",
        "statusCode": "",
        "headers": {},
        "x": 1100,
        "y": 500,
        "wires": []
    },
    {
        "id": "3aea589e.262988",
        "type": "join",
        "z": "3a312453.f7e23c",
        "name": "Join Responses",
        "mode": "custom",
        "build": "array",
        "property": "payload",
        "propertyType": "msg",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": true,
        "accumulate": false,
        "timeout": "2",
        "count": "2",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 881,
        "y": 500,
        "wires": [
            [
                "6099f061.898ce8",
                "4ffa9cdd.4e5544"
            ]
        ]
    },
    {
        "id": "165be43a.2f0cac",
        "type": "debug",
        "z": "3a312453.f7e23c",
        "name": "",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "x": 470,
        "y": 580,
        "wires": []
    },
    {
        "id": "2c7aa6af.428d12",
        "type": "debug",
        "z": "3a312453.f7e23c",
        "name": "",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 570,
        "y": 280,
        "wires": []
    },
    {
        "id": "f5fb6bab.a9da1",
        "type": "debug",
        "z": "3a312453.f7e23c",
        "name": "",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 850,
        "y": 280,
        "wires": []
    },
    {
        "id": "4ffa9cdd.4e5544",
        "type": "debug",
        "z": "3a312453.f7e23c",
        "name": "",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "x": 971,
        "y": 580,
        "wires": []
    },
    {
        "id": "a2ebb2d6.c26e1",
        "type": "debug",
        "z": "3a312453.f7e23c",
        "name": "",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "x": 150,
        "y": 580,
        "wires": []
    },
    {
        "id": "c5194ed0.a1db28",
        "type": "debug",
        "z": "3a312453.f7e23c",
        "name": "",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "x": 670,
        "y": 580,
        "wires": []
    },
    {
        "id": "8c18a8c4.384df",
        "type": "comment",
        "z": "3a312453.f7e23c",
        "name": "## Instructies ##  -  Proxy van HA Gielz Zendure-HA-zenSDK naar 2x Zendure SF2400AC",
        "info": "- Zendure-zenSDK-proxy -\n- versie 20260213\n- https://github.com/gast777/Zendure-zenSDK-proxy\n\n\n\n#### Instructies ####\n\nDe Gielz automatisering voor Zendure ( https://github.com/Gielz1986/Zendure-HA-zenSDK ) is heel mooi en nuttig om een Zendure thuisbatterij die de ZenSDK API ondersteunt, lokaal te besturen, waarbij geen cloud comminicatie nodig is. De standaard Gielz automatisering ondersteunt echter slechts 1 Zendure device (omvormer).\n\nDeze Node-Red flow maakt het mogelijk de Gielz automatisering te gebruiken met twee Zendure devices, zoals 2x Solarflow 2400AC.\n\nNa importeren van deze Node-Red flow in je Node-Red server, kun je je eigen IP adressen en de serienummers van je twee Zendure devices invullen in de Node-Red flow. Hieronder staat aangegeven waar je dat kunt doen.\n\nVervolgens moet je een paar eenvoudige instellingen aanpassen op het dashboard in HomeAssistant, ten opzichte van de normale situatie met 1 device zonder deze proxy. \n\n\n### Node-Red ###\n\n- Vul in het blok \"Vul hier de Zendure IP adressen in\" de IP adressen van de Zendure devices in.\n\n\n### HomeAssistant ###\n\n**Voor up-to-date instructies, kijk op https://github.com/gast777/Zendure-zenSDK-proxy**\n\nVanaf de Maart 2026 versie van de Gielz ZenSDK slechts 2 stappen, beide via het dashboard:\n\n- Op het HA Dashboard, vul het IP adres en poort van de Node-Red proxy in voor \"Zendure 2400 AC IP-adres\" (input_text.zendure_2400_ac_ip_adres). \nBijvoorbeeld: 192.168.x.x:1880 of 192.168.x.x:1880/endpoint\n\n- Vul het \"Maximaal Oplaadvermogen / Ontlaadvermogen\" in op de gewenste waarde, zoals 4800 Watt voor 2x SolarFlow 2400AC, met behulp van de \ninvulvelden input_number.zendure_2400_ac_max_ontlaadvermogen en input_number.zendure_2400_ac_max_oplaadvermogen op het HA dashboard.\n\n\n### Features ###\n\n- SoC balancering - De SoC (state of charge, laadpercentage) van de twee devices wordt dicht bij elkaar gehouden doordat de volste batterij het snelst ontlaadt en de leegste batterij het snelst oplaadt. Bij gelijke SoC laden ze beide even snel.\n- Herhaling van instructies om te laden/ontladen, zodat SoC balancing tussen de Zendures ook werkt voor Handmatige mode.\n- Single Mode - Bij lagere vermogens laadt/ontlaadt slechts een van de Zendures tegelijk. Dit wordt afgewisseld aan de hand van de SoC van de beide devices, waardoor de SoC waardes gebalanceerd blijven.\n- In Single Mode wordt het passieve device (degene die op dat moment niet laadt of ontlaadt) na 5 minuten op standby gezet (smartMode = 0, \"Opslaan in Flash\").\n- In Single Mode wordt naar het andere device overgeschakeld wanneer het verschil in SoC 5% is. Hierdoor wordt minder vaak overgeschakeld van actief device.\n- Bij het overschakelen naar het andere device of van Single Mode naar Dual Mode overschakelen, worden tijdens de overgangsperiode twee devices gebruikt. In het begin krijgt het reeds actieve device 95% van het vermogen toebedeeld, zodat de andere de tijd krijgt om op te starten, voordat die meer vermogen toebedeeld krijgt.\n\n### Vereisten ###\n\n- 2x Zendure SolarFlow 2400 AC (2x Zendure SolarFlow 800 Pro zal ook werken als je \"let maxPower = 2400\" in het blok \"Vul hier de Zendure IP adressen en serienummers in\" verandert naar \"let maxPower = 800\").\n- Zorg dat op beide Zendures hetzelfde maximale en minimale laadpercentage (SoC percentages) ingesteld staan.\n- Beide Zendures moeten hetzelfde aantal batterijen hebben.\n- De beide Zendures en de Node-Red server moeten een vast IP adres hebben.\n- Beide Zendures moeten beschikbaar zijn en werken.\n\n\n### Beperkingen ###\n\n- Bij een instructie van 0 Watt laden levert een Zendure device soms rond de 20 Watt. Dit is momenteel Zendure gedrag en geen probleem.\n- Met Node-Red 4.0.9 zijn er door een gebruiker problemen gerapporteerd, die met versie 4.1.2 niet meer optraden. Node-Red versie 4.1.1 is ook getest en werkt prima.\n\n\n",
        "x": 330,
        "y": 40,
        "wires": []
    },
    {
        "id": "9eaa2918.8e1398",
        "type": "inject",
        "z": "3a312453.f7e23c",
        "name": "Initialize",
        "props": [
            {
                "p": "payload",
                "v": "",
                "vt": "date"
            },
            {
                "p": "topic",
                "v": "",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 100,
        "y": 100,
        "wires": [
            [
                "f3cbccb4.36d65"
            ]
        ]
    },
    {
        "id": "f3cbccb4.36d65",
        "type": "function",
        "z": "3a312453.f7e23c",
        "name": "===> Vul hier de Zendure IP adressen in <===",
        "func": "\n\n//===============================================================\n//== Vul hier de Zendure device IP adressen in ==\n//===============================================================\n\nlet ipZendure1 = \"192.168.x.x\"\nlet ipZendure2 = \"192.168.x.y\"\n\n\n// NB: Na aanpassingen in deze file, druk de Initialize box aan. \n// Dan wordt deze code uitgevoerd en de variabelen geupdated.\n// Ook als een Zendure omvormer wordt vervangen en dus het serienummer\n// wijzigt, druk dan even op Initialize om de serienummers opnieuw\n// in te lezen.\n//===============================================================\n//\n//\n//===============================================================\n// Optioneel tweakbare variabelen:\n\nlet singleMode_upperlimit_percent = 100 // Default 100% van maxPower; Boven dit vermogen wordt overgeschakeld naar beide devices gebruiken voor laden/ontladen.\nlet singleMode_lowerlimit_percent = 40 // Default 40% van maxPower; Onder dit vermogen wordt overgeschakeld naar 1 device gebruiken voor laden/ontladen (single mode).\nlet singleMode_change_device_diff = 5 // Default 5%; Moet 1 of hoger zijn; Bij hoeveel procentpunt verschil in laadpercentage (SoC%) gewisseld wordt van actief device   \n                                      // in single mode.\nlet singleMode_delayed_standby_timer = 300 // Default 300; na hoeveel seconden het passieve device in sigle mode in de slaapstand gezet wordt (smartmode=0, Opslaan in Flash)                        \n//===============================================================\n//\n//\n//===============================================================\n// Niet aanbevolen om aan te passen:\n\nlet manualMode_messageRepeat = 1 // 1: yes, 0: no; Default 1; In non-NOM situation (manual mode), SoC balancing between devices does not work if this is disabled, because \n                                 // the distribution of power happens only on every message with power value (charge/discharge) which is sent. With Manual mode, the power message\n                                 // is sent only at the beginning. This option enables repeating of the message so that power distribution over the devices will be done again.\nlet singleModeDeviceChangeTranstion_timer = 35  // Default 35; for how many seconds we force temporary dual mode when the active device in single mode is changing (for a smoother transition)\nlet balancingFactor = 1.15 // Default 1.15; this lets the device that needs to charge/discharge faster (in dual mode)\n                           // for balancing, to do it faster to reach balance earlier.\n                           // Must be 1 or higher.\nlet singleMode_enable = 1 // Default 1; to use single mode operation at lower power (1 = yes, 0 = no)\nlet singleMode_delayed_standby_charging_enable = 1 // 1: yes, 0: no; Default 0; When in SingleMode, let the passive device go to a deep standby (smartMode=0) after some time when charging.\nlet singleMode_delayed_standby_discharging_enable = 1 // 1: yes, 0: no; Default 1; When in SingleMode, let the passive device go to a deep standby (smartMode=0) after some time when discharging.\n\n//===============================================================\n\n\n// Calculate other parameters\nlet balancingFactor_reduced = (((balancingFactor - 1)) / 2) + 1  //reduced balancingfactor is 1/2 of normal balancingfactor (to be used when soc% have only 1% diff)\n\n// Save to global variables\nflow.set('ipZendure1', ipZendure1)\nflow.set('ipZendure2', ipZendure2)\nflow.set('singleMode_enable', singleMode_enable)\nflow.set('balancingFactor', balancingFactor)\nflow.set('balancingFactor_reduced', balancingFactor_reduced)\nflow.set('manualMode_messageRepeat', manualMode_messageRepeat)\nflow.set('singleMode_change_device_diff', singleMode_change_device_diff)\nflow.set('singleMode_delayed_standby_charging_enable', singleMode_delayed_standby_charging_enable)\nflow.set('singleMode_delayed_standby_discharging_enable', singleMode_delayed_standby_discharging_enable)\nflow.set('singleMode_delayed_standby_timer', singleMode_delayed_standby_timer)\nflow.set('singleModeDeviceChangeTranstion_timer', singleModeDeviceChangeTranstion_timer)\nflow.set('singleMode_upperlimit_percent', singleMode_upperlimit_percent)\nflow.set('singleMode_lowerlimit_percent', singleMode_lowerlimit_percent)\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 100,
        "wires": [
            [
                "80c2e4107ad30741"
            ]
        ]
    },
    {
        "id": "e2d5e713.0a3b1",
        "type": "function",
        "z": "3a312453.f7e23c",
        "name": "Set URL",
        "func": "\n\n// read serial numbers and IP addresses from global variable\nvar snZendure1 = flow.get('snZendure1') || \"0\";\nvar snZendure2 = flow.get('snZendure2') || \"0\";\nvar ipZendure1 = flow.get('ipZendure1') || \"0\";\nvar ipZendure2 = flow.get('ipZendure2') || \"0\";\n\n\nif (ipZendure1 === \"0\" || ipZendure2 === \"0\") {\n    return [null, null, null];\n}\n\nif (snZendure1 === \"0\" || snZendure2 === \"0\") {\n    //node.warn(\"Fetching serialnrs... \");\n    return [msg, null, null]; \n}\n\n// Define target servers\nlet server1 = \"http://\" + ipZendure1 + \"/properties/report\";\nlet server2 = \"http://\" + ipZendure2 + \"/properties/report\";\n\n// Keep a reference to req/res for later response\nlet req = msg.req;\nlet res = msg.res;\n\n// The incoming POST body\nlet data = msg.payload;\n\n// Make copies of the payload so we don't overwrite it\nlet data1 = JSON.parse(JSON.stringify(data));\n\n// Build the message\nlet msg1 = {\n    method: \"GET\",\n    url: server1,\n    headers: { \"Content-Type\": \"application/json\" },\n    payload: data1,\n    req: req,\n    res: res\n};\nlet msg2 = {\n    method: \"GET\",\n    url: server2,\n    headers: { \"Content-Type\": \"application/json\" },\n    payload: data1,\n    req: req,\n    res: res\n};\n\n\n\nreturn [null, msg1, msg2];",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 240,
        "y": 380,
        "wires": [
            [
                "80c2e4107ad30741"
            ],
            [
                "1aff08e7.0a1067"
            ],
            [
                "2eb9ba4e.e23d06"
            ]
        ]
    },
    {
        "id": "5047e3ef.e6c234",
        "type": "inject",
        "z": "3a312453.f7e23c",
        "name": "Trigger messageRepeat",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "20",
        "crontab": "",
        "once": true,
        "onceDelay": "11",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 680,
        "wires": [
            [
                "c3e07eee.f3d9c8"
            ]
        ]
    },
    {
        "id": "505630e.724c8d",
        "type": "debug",
        "z": "3a312453.f7e23c",
        "name": "",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "x": 570,
        "y": 740,
        "wires": []
    },
    {
        "id": "c3e07eee.f3d9c8",
        "type": "function",
        "z": "3a312453.f7e23c",
        "name": "Resend POST",
        "func": "\n/*\nThis block will repeat power the messages to the Node-Red proxy, so that SoC balancing of power will be re-calculated and updated.\nThis is useful for manual mode because that will just send one message and then SoC balancing does not work over longer time.\nIt will keep repeating messages when power is non-zero. For zero power messages there will be no repeat.\n*/\n\n\n\nlet debug = 0 // set to 1 to enable debugging\n\n\n// exit in case socLimit is reached (value 1 or 2)\nvar socLimit_A = flow.get('socLimit_A') || 0;\nvar socLimit_B = flow.get('socLimit_B') || 0;\nif (socLimit_A !== 0 && socLimit_B !== 0) {\n    if (debug == 1) {\n        node.warn(\"socLimit_A is \" + socLimit_A + \", socLimit_B is \" + socLimit_B + \", exit.\");\n    }\n    return null;\n}\n\nvar manualMode_messageRepeat = flow.get('manualMode_messageRepeat')||1;\nvar repeat = 1\n\nif (manualMode_messageRepeat === 0) {\n    return null;\n}\n\nvar latestPowerMessage_timestamp_epoch = flow.get('latestPowerMessage_timestamp_epoch') || 1\nvar latestGETMessage_timestamp_epoch = flow.get('latestGETMessage_timestamp_epoch') || 1\n\nvar time = Math.floor(Date.now() / 1000)\nlet latestPowerMessage_age = time - latestPowerMessage_timestamp_epoch\nlet latestGETMessage_age = time - latestGETMessage_timestamp_epoch\n\n\nif (debug == 1) {\n    node.warn(\"latestPowerMessage_age is \" + latestPowerMessage_age);\n}\n\nif (latestPowerMessage_age < 30) { // do not send message if younger than 30 seconds\n    if (debug == 1) {\n       node.warn(\"latestPowerMessage_age is \" + latestPowerMessage_age + \", exit.\");\n    }\n    return null;\n}\n\nif (latestGETMessage_age > 10) { // do not send message if there has not been any GET message anymore from HA for >30 seconds\n    if (debug == 1) {\n       node.warn(\"latestGETMessage_age is \" + latestGETMessage_age + \", exit.\");\n    }\n    return null;\n}\n\nvar latestPowerMessage_host = flow.get('latestPowerMessage_host')||\"localhost:1880\";\nvar latestPowerMessage = flow.get('latestPowerMessage');\n\nif (!latestPowerMessage) {\n    if (debug == 1) {\n       node.warn(\"latestPowerMessage is not available, exit.\");\n    }\n    return null;\n}\n\nlet data = latestPowerMessage  //this is intentionally not a deep clone. as a result, the repeat value will keep counting up now on every repeat.\n\n\nif (typeof data.repeat != \"undefined\" ) {\n    repeat = data.repeat + 1;\n}\n\nif (typeof data.properties != \"undefined\" ) {\n\n        if (typeof data.properties.inputLimit != \"undefined\") {\n            if (data.properties.inputLimit === 0) {\n                if (debug == 1) {\n                    node.warn(\"Power value is zero, exit.\");\n                }\n                return null;\n            }\n        }\n        if (typeof data.properties.outputLimit != \"undefined\") {\n            if (data.properties.outputLimit === 0) {\n                if (debug == 1) {\n                    node.warn(\"Power value is zero, exit.\");\n                }\n                return null;\n            }\n        }\n        \n        \n       // Build the message\n        data.repeat = repeat  // mark the packet that it is a repeat message and how often repeated\n        var url = \"http://\" + latestPowerMessage_host \n\n        msg = {\n            method: \"POST\",\n            url: url,\n            headers: { \"Content-Type\": \"application/json\" },\n            payload: data,\n        };\n\n        return msg;\n}\n\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 680,
        "wires": [
            [
                "4205f0cc.926988",
                "505630e.724c8d"
            ]
        ]
    },
    {
        "id": "4205f0cc.926988",
        "type": "http request",
        "z": "3a312453.f7e23c",
        "name": "Send HTTP",
        "method": "use",
        "ret": "obj",
        "paytoqs": false,
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "authType": "",
        "x": 590,
        "y": 680,
        "wires": [
            []
        ]
    },
    {
        "id": "2ea3413.8e91f3e",
        "type": "comment",
        "z": "3a312453.f7e23c",
        "name": "Repeat POST for manualMode SoC balancing",
        "info": "This part is the rest api proxy used to receive the POST request from HA (Gielz) and forward it to both Zedure devices.\n\n\nTo do:\n- add timestamps and check for age in this block.\n- run it periodically (from trigger or configurable sleep in a loop)\n- repeat only if power is not zero",
        "x": 190,
        "y": 640,
        "wires": []
    },
    {
        "id": "b31fd166f42b3e49",
        "type": "inject",
        "z": "3a312453.f7e23c",
        "name": "Trigger SingleMode Standby",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "10",
        "crontab": "",
        "once": true,
        "onceDelay": "10",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 800,
        "wires": [
            [
                "49b8285f2d889adb"
            ]
        ]
    },
    {
        "id": "86f2deb9bd25dd32",
        "type": "debug",
        "z": "3a312453.f7e23c",
        "name": "",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "x": 570,
        "y": 860,
        "wires": []
    },
    {
        "id": "49b8285f2d889adb",
        "type": "function",
        "z": "3a312453.f7e23c",
        "name": "Set Standby mode",
        "func": "\n/*\nThis block will send a message to the passive device during singleMode operation (just one device charging/discharging and the other one stays at 0 power) to \nset it to deeper standby mode (smartmode=0). This will make the battery to use less standby power. On the other hand it makes the device slower to startup when \nit needs to start charging/discharging.\n*/\n\n\nlet debug = 0 // set to 1 to enable debugging\n\n\n// load from global variables\nvar singleMode = flow.get('singleMode')||0;\nvar latestPowerCmd = flow.get('latestPowerCmd')||0;\nvar latestPowerCmd_1_zero_timestamp = flow.get('latestPowerCmd_1_zero_timestamp')||1;\nvar latestPowerCmd_2_zero_timestamp = flow.get('latestPowerCmd_2_zero_timestamp')||1;\nvar singleMode_delayed_standby_timer = flow.get('singleMode_delayed_standby_timer')||300;\nvar singleMode_delayed_standby_charging_enable = flow.get('singleMode_delayed_standby_charging_enable')||0;\nvar singleMode_delayed_standby_discharging_enable = flow.get('singleMode_delayed_standby_discharging_enable')||0;\nvar singleMode_delayed_standby_last_sent_timestamp = flow.get('singleMode_delayed_standby_last_sent_timestamp')||0;\nvar smartMode_A = flow.get('smartMode_A')||0;\nvar smartMode_B = flow.get('smartMode_B')||0;\nvar singleMode_change_device_diff = flow.get('singleMode_change_device_diff')||1;\nvar electricLevel_A = flow.get('electricLevel_A')||50;\nvar electricLevel_B = flow.get('electricLevel_B')||50;\nvar dualMode_force_start_timestamp = flow.get('dualMode_force_start_timestamp') || 1;\nvar singleToDualModeTransition_start_timestamp = flow.get('singleToDualModeTransition_start_timestamp') || 1;\nvar singleModeDeviceChangeTranstion_timer = flow.get('singleModeDeviceChangeTranstion_timer') || 1;\n\nlet date = new Date(singleMode_delayed_standby_last_sent_timestamp * 1000);\nlet currentTime = Math.floor(Date.now() / 1000)\n\n\n// exit if singleMode_delayed_standby feature is not enabled for charging nor discharging\nif (singleMode_delayed_standby_charging_enable != 1 && singleMode_delayed_standby_discharging_enable != 1) {\n    if (debug == 1) {\n        node.warn(\"exit, singleMode_delayed_standby is not enabled \");\n    }\n    return null;\n}\n\n// exit if not running singleMode now\nif (debug == 1) {\n    node.warn(\"singleMode is \" + singleMode);\n}\nif (singleMode === 0) {\n    return null;\n}\n\n\n// exit during transition + 10 seconds at starting new device\nif ((currentTime - singleToDualModeTransition_start_timestamp < singleModeDeviceChangeTranstion_timer + 10) || (currentTime - dualMode_force_start_timestamp < singleModeDeviceChangeTranstion_timer + 10)) {  //check for transition being active\n    return null;\n}  \n\n\n\n// exit if latestPowerCmd == 0\nif (latestPowerCmd == 0) {\n    if (debug == 1) {\n        node.warn(\"exit, latestPowerCmd is zero\");\n    }\n    return null;\n}\n\n// exit if singleMode_delayed_standby_charging_enable not enabled and latestPowerCmd > 0\nif ( singleMode_delayed_standby_charging_enable != 1 && latestPowerCmd > 0) {\n    if (debug == 1) {\n        node.warn(\"exit, singleMode_delayed_standby_charging_enable not enabled and we are charging\");\n    }\n    return null;\n}\n\n// exit if singleMode_delayed_standby_discharging_enable not enabled and latestPowerCmd < 0\nif ( singleMode_delayed_standby_discharging_enable != 1 && latestPowerCmd < 0) {\n    if (debug == 1) {\n        node.warn(\"exit, singleMode_delayed_standby_discharging_enable not enabled and we are discharging\");\n    }\n    return null;\n}\n\n// Optimization: Do not trigger standby when charging and percentage diff is still the singleMode_change_device_diff, because if power is drawn suddenly, it will trigger other device to discharge\n// (mostly covered already by the timeout, but let's block it fully even after the timeout)\n// we do it only for charging because discharging, at least with NOM is often when sun is not shining en no risk to have to change device again. Discharging \n// during day will still have that risk, but is mostly anyway covered by the standby timeout.\n// Note, if charging stopped, anyway Gielz will send Standby command, so we won't stay indefinitely without Standby in this case.\nif (\n    latestPowerCmd > 0 &&\n    (\n        (electricLevel_A - electricLevel_B) === singleMode_change_device_diff ||\n        (electricLevel_B - electricLevel_A) === singleMode_change_device_diff\n    )\n) {\n    return null;\n}\n\n\n// exit if one of the timestamps is the one that a message is already sent for\nif ((latestPowerCmd_1_zero_timestamp == singleMode_delayed_standby_last_sent_timestamp) || (latestPowerCmd_2_zero_timestamp == singleMode_delayed_standby_last_sent_timestamp)) {\n    if (debug == 1) {\n            node.warn(\"message already sent for this timestamp \" + singleMode_delayed_standby_last_sent_timestamp + \" \" + date + \"and one device is already in standby.\");\n        }    \n    \n    if (smartMode_A == 0 || smartMode_B == 0) { // check if one of them is actually in smartMode 0 (standby). Only then exit. Otherwise continue to send it again.\n\n        if (debug == 1) {\n            node.warn(\"and one device is already in standby. Exit.\");\n        }\n        return null;\n    } else {\n        if (debug == 1) {\n            node.warn(\"but no device in standby anymore. Continue.\");\n        }\n    }\n\n}\n\n// Exit if NOT exactly one timestamp is 1\nif (!((latestPowerCmd_1_zero_timestamp == 1) !== (latestPowerCmd_2_zero_timestamp == 1))) {   //XOR, if NOT only one of them is zero)\n    if (debug == 1) {\n        node.warn(\"exit, NOT exactly one timestamp is 1\");\n    }\n    return null;\n}\n\n\n//exit if no GET message was passed for a while\nvar latestGETMessage_timestamp_epoch = flow.get('latestGETMessage_timestamp_epoch') || 1\nlet latestGETMessage_age = currentTime - latestGETMessage_timestamp_epoch\n\n\nif (latestGETMessage_age > 10) { // do not send message if there has not been any GET message anymore from HA for >10 seconds\n    if (debug == 1) {\n        node.warn(\"exit, latest GET message from HA is > 10 seconds ago\");\n    }\n    return null;\n}\n\nif (debug == 1) {\n    node.warn(\"latestPowerCmd_1_zero_timestamp is \" + latestPowerCmd_1_zero_timestamp);\n    node.warn(\"latestPowerCmd_2_zero_timestamp is \" + latestPowerCmd_2_zero_timestamp);\n    node.warn(\"singleMode_delayed_standby_last_sent_timestamp is \" + singleMode_delayed_standby_last_sent_timestamp + \" \" + date);\n    node.warn(\"singleMode_delayed_standby_timer is \" + singleMode_delayed_standby_timer);\n}\n\n\n\n// read serial numbers and IP addresses from global variable (can be modified in block \"Vul hier de Zendure IP adressen en serienummers in\")\nvar snZendure1 = flow.get('snZendure1')||1;\nvar snZendure2 = flow.get('snZendure2')||1;\nvar ipZendure1 = flow.get('ipZendure1')||1;\nvar ipZendure2 = flow.get('ipZendure2')||1;\n\n// Define target servers\nlet server1 = \"http://\" + ipZendure1 + \"/properties/write\";\nlet server2 = \"http://\" + ipZendure2 + \"/properties/write\";\n\n//define the data for the message\nlet data = {}\ndata.properties = {}\ndata.properties.smartMode = 0\ndata.properties.outputLimit = 0\ndata.properties.inputLimit = 0\n\n// Calculate age, to check how long one is already at zero\nlet latestPowerCmd_1_zero_timestamp_age = currentTime - latestPowerCmd_1_zero_timestamp\nlet latestPowerCmd_2_zero_timestamp_age = currentTime - latestPowerCmd_2_zero_timestamp\n\n\n\n\n// smallest age is not 1 and is the relevant device\nif (latestPowerCmd_1_zero_timestamp_age < latestPowerCmd_2_zero_timestamp_age) { //device 1 is the relevant \n\n    if (latestPowerCmd_1_zero_timestamp_age > singleMode_delayed_standby_timer) { //check age\n        if (debug == 1) {\n            flow.set('latestPowerCmd_1_zero_timestamp_age', latestPowerCmd_1_zero_timestamp_age)\n            flow.set('singleMode_delayed_standby_timer', singleMode_delayed_standby_timer)\n            node.warn(\"sending smartmode=0 to Zendure 1 \");\n        }\n        var url = server1\n        data.sn = snZendure1\n        flow.set('singleMode_delayed_standby_last_sent_timestamp', latestPowerCmd_1_zero_timestamp)\n        flow.set('singleMode_standby_device_A', 1)\n    } else {\n        return null;\n    }\n\n} else {         //device 2 is the relevant\n\n    if (latestPowerCmd_2_zero_timestamp_age > singleMode_delayed_standby_timer) { //check age\n        if (debug == 1) {\n            flow.set('latestPowerCmd_2_zero_timestamp_age', latestPowerCmd_2_zero_timestamp_age)\n            flow.set('singleMode_delayed_standby_timer', singleMode_delayed_standby_timer)\n            node.warn(\"sending smartmode=0 to Zendure 2 \");\n        }\n        var url = server2\n        data.sn = snZendure2\n        flow.set('singleMode_delayed_standby_last_sent_timestamp', latestPowerCmd_2_zero_timestamp)\n        flow.set('singleMode_standby_device_B', 1)\n    } else {\n        return null;\n    }\n}\n\n\n// Build the message to be sent\nmsg = {\n    method: \"POST\",\n    url: url,\n    headers: { \"Content-Type\": \"application/json\" },\n    payload: data,\n};\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 800,
        "wires": [
            [
                "d84308ea0c1b02ad",
                "86f2deb9bd25dd32"
            ]
        ]
    },
    {
        "id": "d84308ea0c1b02ad",
        "type": "http request",
        "z": "3a312453.f7e23c",
        "name": "Send HTTP",
        "method": "use",
        "ret": "obj",
        "paytoqs": false,
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "authType": "",
        "x": 590,
        "y": 800,
        "wires": [
            []
        ]
    },
    {
        "id": "0bfbc77080d4bb92",
        "type": "comment",
        "z": "3a312453.f7e23c",
        "name": "Send smartMode=0 for deep Standby mode",
        "info": "",
        "x": 190,
        "y": 760,
        "wires": []
    },
    {
        "id": "a863e1a6835839b6",
        "type": "inject",
        "z": "3a312453.f7e23c",
        "name": "Periodic trigger",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "10",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 860,
        "y": 720,
        "wires": [
            [
                "596d43af2101c485"
            ]
        ]
    },
    {
        "id": "596d43af2101c485",
        "type": "function",
        "z": "3a312453.f7e23c",
        "name": "Check stuff",
        "func": "\n/*\nThis block runs periodically to do some calculations and checks.\n*/\n\n// load global variables\nvar chargeMaxLimit_A = flow.get('chargeMaxLimit_A') || 0;\nvar chargeMaxLimit_B = flow.get('chargeMaxLimit_B') || 0;\nvar inverseMaxPower_A = flow.get('inverseMaxPower_A') || 0;\nvar inverseMaxPower_B = flow.get('inverseMaxPower_B') || 0;\nvar chargeMaxLimit_unequal_error = flow.get('chargeMaxLimit_unequal_error') || 0;\nvar inverseMaxPower_unequal_error = flow.get('inverseMaxPower_unequal_error') || 0;\nvar minSoc_unequal_error = flow.get('minSoc_unequal_error') || 0;\nvar socSet_unequal_error = flow.get('socSet_unequal_error') || 0;\nvar singleMode_upperlimit_percent = flow.get('singleMode_upperlimit_percent') || 100;\nvar singleMode_lowerlimit_percent = flow.get('singleMode_lowerlimit_percent') || 40;\nvar maxPower_in = flow.get('maxPower_in') || 0;\nvar maxPower_out = flow.get('maxPower_out') || 0;\nvar minSoc_A = flow.get('minSoc_A') || 0;\nvar minSoc_B = flow.get('minSoc_B') || 0;\nvar socSet_A = flow.get('socSet_A') || 0;\nvar socSet_B = flow.get('socSet_B') || 0;\nvar payloadError = flow.get('payloadError') || 0;\nvar payloadError_previous = flow.get('payloadError_previous') || 0;\n\n\n\n//throw a warning if there are multiple errors in payload counted by \"Get Response Handling\" node since previous check\nlet payloadError_diff = payloadError - payloadError_previous;\nif (payloadError_diff > 1) {\n    node.warn(\"Mogelijk communicatieprobleem tussen Node-Red en de Zendure devices!\")\n}\nflow.set('payloadError_previous', payloadError)\n\n\n//throw a warning if chargeMaxLimit or inverseMaxPower is not the same on both devices\nif (chargeMaxLimit_A !== chargeMaxLimit_B) {\n    chargeMaxLimit_unequal_error = chargeMaxLimit_unequal_error + 1;\n} else {\n    chargeMaxLimit_unequal_error = 0;\n}\nflow.set('chargeMaxLimit_unequal_error', chargeMaxLimit_unequal_error)\n\nif (chargeMaxLimit_unequal_error > 2) {\n    node.warn(\"Max. Oplaadvermogen is niet gelijk op beide devices: \" + chargeMaxLimit_A + \" en \" + chargeMaxLimit_B);\n}\n\nif (inverseMaxPower_A !== inverseMaxPower_B) {\n    inverseMaxPower_unequal_error = inverseMaxPower_unequal_error + 1;\n} else {\n    inverseMaxPower_unequal_error = 0;\n}\nflow.set('inverseMaxPower_unequal_error', inverseMaxPower_unequal_error)\n\nif (inverseMaxPower_unequal_error > 2) {\n    node.warn(\"Max. Ontlaadvermogen is niet gelijk op beide devices: \" + inverseMaxPower_A + \" en \" + inverseMaxPower_B);\n}\n\n\n\n//throw a warning if minSoc or socSet is not the same on both devices\nif (minSoc_A !== minSoc_B) {\n    minSoc_unequal_error = minSoc_unequal_error + 1;\n} else {\n    minSoc_unequal_error = 0;\n}\nflow.set('minSoc_unequal_error', minSoc_unequal_error)\n\nif (minSoc_unequal_error > 6) {\n    node.warn(\"Minimale Laadpercentage is niet gelijk op beide devices: \" + minSoc_A / 10 + \"% en \" + minSoc_B / 10 + \"%\");\n}\n\nif (socSet_A !== socSet_B) {\n    socSet_unequal_error = socSet_unequal_error + 1;\n} else {\n    socSet_unequal_error = 0;\n}\nflow.set('socSet_unequal_error', socSet_unequal_error)\n\nif (socSet_unequal_error > 6) {\n    node.warn(\"Maximale Laadpercentage is niet gelijk op beide devices: \" + socSet_A / 10 + \"% en \" + socSet_B / 10 + \"%\");\n}\n\n\n\n\n// This was taken out of block \"GET Response handling\", to not slow that down unecessarily.\n// We calculate these values here. Due to lower frequency it will take a bit more time to adjust the values after changing \n// the max power, but that is not done often anyway.\n//Calculate singleMode thresholds power (Watt) based on maxpower\n// singleMode thresholds can be different for in and out directions, depending on maxpower in that direction\nlet singleMode_upperlimit_in = singleMode_upperlimit_percent / 100 * maxPower_in\nlet singleMode_upperlimit_out = singleMode_upperlimit_percent / 100 * maxPower_out\nlet singleMode_lowerlimit_in = singleMode_lowerlimit_percent / 100 * maxPower_in\nlet singleMode_lowerlimit_out = singleMode_lowerlimit_percent / 100 * maxPower_out\nflow.set('singleMode_upperlimit_in', singleMode_upperlimit_in)\nflow.set('singleMode_upperlimit_out', singleMode_upperlimit_out)\nflow.set('singleMode_lowerlimit_in', singleMode_lowerlimit_in)\nflow.set('singleMode_lowerlimit_out', singleMode_lowerlimit_out)\n\n\n\n\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1030,
        "y": 720,
        "wires": [
            []
        ]
    },
    {
        "id": "defcda6c0d657406",
        "type": "comment",
        "z": "3a312453.f7e23c",
        "name": "Periodic run",
        "info": "",
        "x": 830,
        "y": 680,
        "wires": []
    },
    {
        "id": "80c2e4107ad30741",
        "type": "function",
        "z": "3a312453.f7e23c",
        "name": "Fetch Serialnrs",
        "func": "\n\n// read IP addresses from global variable\nvar ipZendure1 = flow.get('ipZendure1')||1;\nvar ipZendure2 = flow.get('ipZendure2')||1;\n\n\n// Define target servers\nlet server1 = \"http://\" + ipZendure1 + \"/properties/report\";\nlet server2 = \"http://\" + ipZendure2 + \"/properties/report\";\n\n\n// Build the message\nlet msg1 = {\n    method: \"GET\",\n    url: server1,\n    headers: { \"Content-Type\": \"application/json\" },\n};\n\nlet msg2 = {\n    method: \"GET\",\n    url: server2,\n    headers: { \"Content-Type\": \"application/json\" },\n};\n\n\n\nreturn [msg1, msg2];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 340,
        "y": 200,
        "wires": [
            [
                "80bc512a71f2d7e2"
            ],
            [
                "ba4b9d68dfb605c4"
            ]
        ]
    },
    {
        "id": "80bc512a71f2d7e2",
        "type": "http request",
        "z": "3a312453.f7e23c",
        "name": "Call Zendure 1 API",
        "method": "use",
        "ret": "obj",
        "paytoqs": true,
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "authType": "",
        "x": 550,
        "y": 180,
        "wires": [
            [
                "9638903f7bcd3dae"
            ]
        ]
    },
    {
        "id": "9638903f7bcd3dae",
        "type": "function",
        "z": "3a312453.f7e23c",
        "name": "GET SN Zendure 1",
        "func": "/*\nFetch the serialnr from the Zendure devices and put in a global variable.\n*/\n\nvar payloadError = flow.get('payloadError') || 0;\n\n\n// exit gracefully in case of error and count the error to a global variable\nif (!msg.payload) {\n    payloadError = payloadError + 1;\n    flow.set('payloadError', payloadError);\n    return null;\n}\n\n\nlet data = JSON.parse(JSON.stringify(msg.payload || {}));\n\nlet snZendure1 = data.sn || \"0\";\n\nif (snZendure1 !== \"0\") {\n    flow.set('snZendure1', snZendure1);\n    //node.warn(\"snZendure1 is \" + snZendure1);\n}\n\n\n\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 180,
        "wires": [
            []
        ]
    },
    {
        "id": "ba4b9d68dfb605c4",
        "type": "http request",
        "z": "3a312453.f7e23c",
        "name": "Call Zendure 2 API",
        "method": "use",
        "ret": "obj",
        "paytoqs": "query",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 550,
        "y": 220,
        "wires": [
            [
                "d3118f8404355e9b"
            ]
        ]
    },
    {
        "id": "d3118f8404355e9b",
        "type": "function",
        "z": "3a312453.f7e23c",
        "name": "GET SN Zendure 2",
        "func": "/*\nFetch the serialnr from the Zendure devices and put in a global variable.\n*/\n\nvar payloadError = flow.get('payloadError') || 0;\n\n\n// exit gracefully in case of error and count the error to a global variable\nif (!msg.payload) {\n    payloadError = payloadError + 1;\n    flow.set('payloadError', payloadError);\n    return null;\n}\n\n\nlet data = JSON.parse(JSON.stringify(msg.payload || {}));\n\nlet snZendure2 = data.sn || \"0\";\n\nif (snZendure2 !== \"0\") {\n    flow.set('snZendure2', snZendure2);\n    //node.warn(\"snZendure2 is \" + snZendure2);\n}\n\n\n\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 220,
        "wires": [
            []
        ]
    },
    {
        "id": "2ab89f2a01197d8c",
        "type": "comment",
        "z": "3a312453.f7e23c",
        "name": "Obtaining Serialnrs",
        "info": "\n",
        "x": 350,
        "y": 160,
        "wires": []
    }
]